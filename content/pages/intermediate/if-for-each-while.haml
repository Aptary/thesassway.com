Date: 23 August 2013
Categories: intermediate, guides, adam-stacoviak
Author: Adam Stacoviak
Summary: To write mixins and functions you Sass's control directives, @if @for @each and @while need to be among the first items on your list to learn about Sass. Control directives give your mixins flow and logic and can give you a finite level of decision making required by mixins.

%h1 Sass control directives: @if, @for, @each and @while

:markdown
  [Sass control directives](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#control_directives) are the cornerstone of creating libraries for reuse and distribution. Sass control directives @if, @for, @each and @while need to be among the first items on your list of things to learn when taking your Sass skills to the next level.

  ## Crash course to Sass control directives
  
  Sass control directives provide flow and logic and give you a finite level of decision making required by mixins and functions.
  
  ### @if

  The `@if` control directive takes a [SassScript](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#sassscript) expression and processes its block of styles if the expression returns anything other than `false`.
  
  Here's a fairly simple example of an `@if` control directive. I've simplified this example to be more readable, rather than usable.

      :::sass
      // Set a variable to run the if statement against
      $boolean: true !default

      =if
        @if $boolean
          @debug "$boolean is \#{$boolean}"
          display: block
        @else
          @debug "$boolean is \#{$boolean}"
          display: none
      
      .if
        +if

  Which emits this CSS:

      :::css
      .if {
        display: block;
      }
  
  Also notice that I've added `@debug` followed by a string in each flow option. This isn't core to this guide, but I've add this to show you how you can output a message to the command-line output log to let users know about certain events such as a `@warn` or a `@debug` as your code gets executed. For complex mixins and functions, this could come in handy to provide a better user experience and make it easier to spot and track down issues.
  
  For example, if you ran this code this is what you would see in the command-line output.

      :::bash
      /Users/.../screen.sass:8 DEBUG: $boolean is true
  
  ### @for

  The `@for` directive comes in two forms.
  
  The first option is `@for $var from <start> through <end>` which starts at `<start>` and loops "through" each iteration and ends at `<end>`. Pretty straight forward.
  
  The second option is `@for $var from <start> to <end>` which starts at `<start>` and loops through each iteration "to" `<end>` and stops. Once the directive hits the `<end>` it stops the looping process and does not evaluate the loop that one last time. Using the values mentioned in the example below, it's like saying "go from 1 to 4 and then stop".
  
  In either case, the `$var` can be any variable name. Because this directive is often used to increment `$i` is often the name you will see as the `$var`.
  
  Here's a fairly simple example of a `@for` control directive.

      :::sass
      $class-slug: for !default

      @for $i from 1 through 4
        .\#{$class-slug}-\#{$i}
          width: 60px + $i

  Which emits this CSS:

      :::css
      .for-1 {
        width: 61px;
      }

      .for-2 {
        width: 62px;
      }

      .for-3 {
        width: 63px;
      }

      .for-4 {
        width: 64px;
      }
  
  If you want to see a real world example of a `@for` directive, check out how I've used it in [Grid Coordinates](https://github.com/adamstac/grid-coordinates/blob/master/stylesheets/_grid-coordinates.sass) to create a range of classes on lines 39-55. Now that I look at my code for Grid Coordinates, based on the teachings of this guide, I can see how my code can be re-factored. If you can spot what I'm saying, you're doing just fine.
  
  Here's a sample of the code you'll see in that file.

      :::sass
      // Loops
      @for $i from 1 through $grid-columns
        .grid-\#{$i}
          +grid-base($i)
          @extend .grid-block
      @for $i from 1 through $grid-columns - 1
        .grid-prefix-\#{$i}
          +grid-prefix($i)
      @for $i from 1 through $grid-columns - 1
        .grid-suffix-\#{$i}
          +grid-suffix($i)
      @for $i from 1 through $grid-columns - 1
        .grid-push-\#{$i}
          +grid-push($i)
      @for $i from 1 through $grid-columns - 1
        .grid-pull-\#{$i}
        +grid-pull($i)
  
  ### @each

  The `@each` directive takes the form `@each $var in <list>`. If you haven't played with lists yet, get ready because this has just turned into a 2 in 1 lesson.
  
  As you can see in the example below, `$var` can be any variable name, and `<list>` is a SassScript expression that returns a list. When processed, `$var` is set to each item in the list, and processes its block of styles using that value of `$var`.
  
  Here's a fairly simple example of an `@each` control directive.

      :::sass
      $list: adam john wynn mason kuroir

      =author-images
        @each $author in $list
          .photo-\#{$author}
            background: image-url("avatars/\#{$author}.png") no-repeat

      .author-bio
        +author-images

  Which emits this CSS:

      :::css
      .author-bio .photo-adam {
        background: url('/images/avatars/adam.png') no-repeat;
      }
      .author-bio .photo-john {
        background: url('/images/avatars/john.png') no-repeat;
      }
      .author-bio .photo-wynn {
        background: url('/images/avatars/wynn.png') no-repeat;
      }
      .author-bio .photo-mason {
        background: url('/images/avatars/mason.png') no-repeat;
      }
      .author-bio .photo-kuroir {
        background: url('/images/avatars/kuroir.png') no-repeat;
      }
  
  ### @while

  `@while` - Wui officia deserunt mollit anim id est laborum.

      :sass
      $types: 4
      $type-width: 20px

      @while $types > 0
        .while-#{$types}
          width: $type-width + $types
        $types: $types - 1

  Which emits this CSS:

      :::css
      .while-4 {
        width: 24px;
      }

      .while-3 {
        width: 23px;
      }

      .while-2 {
        width: 22px;
      }

      .while-1 {
        width: 21px;
      }

  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.